





import os
import cv2


def extract_frames(input_dir, frames_per_video):
    video_folders = [f for f in os.listdir(input_dir) if os.path.isdir(os.path.join(input_dir, f))]

    for folder in video_folders:
        folder_path = os.path.join(input_dir, folder)
        output_frames_dir = os.path.join(folder_path, 'video_images')
        os.makedirs(output_frames_dir, exist_ok=True)

        videos = [f for f in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, f))]

        for video in videos:
            video_path = os.path.join(folder_path, video)
            video_name, _ = os.path.splitext(video)
            frame_count = 0

            # Open the video file
            cap = cv2.VideoCapture(video_path)

            # Extract frames
            while cap.isOpened():
                ret, frame = cap.read()
                if not ret:
                    break

                # Save frame as an image
                frame_output_path = os.path.join(output_frames_dir, f'{video_name}_{frame_count}.jpg')
                cv2.imwrite(frame_output_path, frame)

                frame_count += 1
                if frame_count >= frames_per_video:
                    break

            cap.release()


if __name__ == "__main__":
    input_dir = 'split_videos'
    frames_per_video = 10

    extract_frames(input_dir, frames_per_video)


















# gets video id's from csv, gets matching id's in dev-iroccvdmsstack-dmsbucketb119a736-rtlxxvez6thx/frames
def find_matching_video_ids(df, data_dms):
    try:
        # Extract the 'video_id' column into a list
        csv_video_ids = df['video_id'].tolist()

        # Extract the desired values from the given data
        dms_vid_id = []  # frames name from dms upload
        dms_vid_files = []  # frames files from dms upload

        # Iterate through the DMS data and extract directory names and file names
        for item in data_dms:
            key_parts = item['Key'].split('/')
            dir_name = key_parts[1]
            file_name = key_parts[2]
            dms_vid_id.append(dir_name)
            dms_vid_files.append(file_name)

        # Find matching video IDs between CSV data and DMS data
        matching_dirs = []
        matching_file_names = []
        for vid_id in csv_video_ids:
            if vid_id in dms_vid_id:
                index = dms_vid_id.index(vid_id)
                matching_dirs.append(dms_vid_id[index])
                matching_file_names.append(dms_vid_files[index])

        return matching_dirs, matching_file_names

    except KeyError:
        print("Error: 'video_id' column not found in the CSV file.")
        return None, None
    except Exception as e:
        print("An error occurred:", e)
        return None, None



dms_vid_id
[['(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s', '(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000000.jpg'], ['(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s', '(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000001.jpg'], ['(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s', '(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000002.jpg']]

['(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-06.00.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-07.00.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-08.15.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-09.15.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-10.00.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-11.00.00-15m00s', '(10.114.237.108) - TV401C PC1 ROM Bin-2024.04.12-12.00.00-15m00s']
































desired_values = []
for item in data:
    key_parts = item['Key'].split('/')
    if len(key_parts) >= 2:
        desired_values.append(key_parts[1])

print(desired_values)






# Check if GPU is available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Move the model to the appropriate device
model.to(device)

# Move the input tensors to the appropriate device
inputs_gpu = {key: tensor.to(device) for key, tensor in inputs.items()}

# Perform depth estimation
with torch.no_grad():
    outputs = model(**inputs_gpu)
    predicted_depth = outputs.predicted_depth


 Time Step   roi  Time (s)  Mean Depth  Trend
0          0  None      80.0    8.336488      0
   Time Step   roi  Time (s)  Mean Depth  Trend
0          0  None      80.0    8.336488      0
   Time Step    roi  Time (s)  Mean Depth  Trend
0          1  roi_1      80.0    8.332146      0
   Time Step   roi  Time (s)  Mean Depth  Trend
0          0  None      80.0    8.336488      0
   Time Step    roi  Time (s)  Mean Depth  Trend
0          1  roi_1      80.0    8.332146      0
   Time Step    roi  Time (s)  Mean Depth     Trend
0          2  roi_2     160.0    8.336878  0.059152
   Time Step   roi  Time (s)  Mean Depth  Trend
0          0  None      80.0    8.336488      0
   Time Step    roi  Time (s)  Mean Depth  Trend


# Initialize an empty list to store DataFrames
df_list = []

# Your loop to generate DataFrames goes here
for each_iteration:
    # Generate each DataFrame and append it to df_list
    df_list.append(new_df)

# Concatenate DataFrames and filter out rows where 'roi' is 'None'
final_df = pd.concat([df[df['roi'] != 'None'] for df in df_list], ignore_index=True)

# Save final_df to CSV
final_df.to_csv('output.csv', index=False)


FROM nvidia/cuda:12.3.2-base-ubuntu22.04
ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update
RUN apt-get install -y git
RUN apt-get install -y python3.11-dev # Python 3.11 specific items 
RUN apt-get install -y python3-opencv python3-pip 
RUN apt-get install -y libglib2.0-0 # Others

COPY . /home/bhamilton/scripts/depth_anything_special

WORKDIR /home/bhamilton/scripts/depth_anything_special

#COPY requirements.txt /home/bhamilton/scripts/depth_anything_special/requirements.txt

RUN python3 -m pip install -r requirements.txt
RUN python3 -m pip install --upgrade pip


RUN pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121



ENTRYPOINT ["python3", "main.py"]

ERROR [ 9/11] RUN python3 -m pip install -r requirements.txt                                                   1.0s
------
 > [ 9/11] RUN python3 -m pip install -r requirements.txt:
#13 0.942 ERROR: Could not open requirements file: [Errno 2] No such file or directory: 'requirements.txt'
------
executor failed running [/bin/sh -c python3 -m pip install -r requirements.txt]: exit code: 1



[{'Key': 'frames/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000000.jpg', 'LastModified': datetime.datetime(2024, 3, 22, 9, 7, 35, tzinfo=tzlocal()), 'ETag': '"c052a1f3b3eec0ada5bc7fcaaff2152a"', 'Size': 75459, 'StorageClass': 'STANDARD', 'Owner': {'DisplayName': 'dl-aws-iroccompvis-npe', 'ID': '6ad35284ba06a5257f5447cdca1867f06973b2cc6ccd609ff953a8ae9a798386'}}, {'Key': 'frames/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000001.jpg', 'LastModified': datetime.datetime(2024, 3, 22, 9, 7, 36, tzinfo=tzlocal()), 'ETag': '"b8acff1047e4bfbaf16c40e3147c4728"', 'Size': 76281, 'StorageClass': 'STANDARD', 'Owner': {'DisplayName': 'dl-aws-iroccompvis-npe', 'ID': '6ad35284ba06a5257f5447cdca1867f06973b2cc6ccd609ff953a8ae9a798386'}}, {'Key': 'frames/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000002.jpg', 'LastModified': datetime.datetime(2024, 3, 22, 9, 7, 37, tzinfo=tzlocal()), 'ETag': '"913c1b743615b81c029fb9f279ed66b4"', 'Size': 76532, 'StorageClass': 'STANDARD', 'Owner': {'DisplayName': 'dl-aws-iroccompvis-npe', 'ID': '6ad35284ba06a5257f5447cdca1867f06973b2cc6ccd609ff953a8ae9a798386'}}, {'Key': 'frames/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000003.jpg', 'LastModified': datetime.datetime(2024, 3, 22, 9, 7, 37, tzinfo=tzlocal()), 'ETag': '"70a53200c76c836ed41522bff1b208ee"', 'Size': 76648, 'StorageClass': 'STANDARD', 'Owner': {'DisplayName': 'dl-aws-iroccompvis-npe', 'ID': '6ad35284ba06a5257f5447cdca1867f06973b2cc6ccd609ff953a8ae9a798386'}}, {'Key': 'frames/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s/(10.114.193.107) - TV522B TLO2 Chute A Front-2023.05.29-19.59.38-30m21s_0000004.jpg', 'LastModified': datetime.datetime(2024, 3, 22, 9, 7, 37, tzinfo=tzlocal()), 'ETag': '"5e34b596050c9fd8bbc1ab99ec3c2241"', 'Size': 76489, 'StorageClass': 'STANDARD', 'Owner': {'DisplayName': 'dl-aws-iroccompvis-npe', 'ID': '6ad35284ba06a5257f5447cdca1867f06973b2cc6ccd609ff953a8ae9a798386'}}

def find_matching_video_ids(csv_file, data):
    try:
        # Read the CSV file into a pandas DataFrame
        df = pd.read_csv(csv_file)
        
        # Extract the 'video_id' column into a list
        csv_video_ids = df['video_id'].tolist()

        # Extract the desired values from the given data
        desired_values = []
        for item in data:
            key_parts = item['Key'].split('/')
            if len(key_parts) >= 2:
                # Strip the file extension
                filename = os.path.splitext(key_parts[1])[0]
                desired_values.append(filename)

        # Strip the file extensions from csv_video_ids
        csv_video_ids_stripped = [os.path.splitext(video_id)[0] for video_id in csv_video_ids]

        # Find matching values between desired_values and csv_video_ids_stripped using list intersection
        matching_values = list(set(desired_values).intersection(csv_video_ids_stripped))

        return matching_values
    
    except FileNotFoundError:
        print("Error: File not found.")
        return None
    except KeyError:
        print("Error: 'video_id' column not found in the CSV file.")
        return None
    except Exception as e:
        print("An error occurred:", e)
        return None


import boto3
import os
import boto3

import os
import boto3

import os
import boto3

import boto3

def create_directory(s3_client, bucket_name, directory_key):
    try:
        # Check if the directory exists by listing objects with the given prefix
        response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=directory_key)
        if 'Contents' not in response:
            # If the directory doesn't exist, create an empty object to represent it
            s3_client.put_object(Bucket=bucket_name, Key=directory_key.rstrip('/') + '/')
    except Exception as e:
        print("An error occurred while creating directory:", e)

def copy_files(source_bucket, dest_bucket, source_subfolder, dest_subfolder, filenames, step=1):
    try:
        # Initialize S3 client
        s3_client = boto3.client('s3')

        for i, filename in enumerate(filenames):
            if i % step == 0:
                # Construct the source and destination keys
                source_key = f"{source_subfolder}/{filename}"
                dest_key = f"{dest_subfolder}/{os.path.splitext(filename)[0]}/{filename}"

                # Create destination directory if it doesn't exist
                dest_dir = os.path.dirname(dest_key)
                create_directory(s3_client, dest_bucket, dest_dir)

                # Copy the file from the source bucket to the destination bucket
                copy_source = {
                    'Bucket': source_bucket,
                    'Key': source_key
                }
                
                # Perform the S3 copy operation
                s3_client.copy_object(CopySource=copy_source, Bucket=dest_bucket, Key=dest_key)
                
                print(f"File '{filename}' copied successfully to '{dest_bucket}/{dest_key}'.")
    except Exception as e:
        print("An error occurred while copying files:", e)



